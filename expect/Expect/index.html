<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Expect (expect.Expect)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">expect</a> &#x00BB; Expect</nav><header class="odoc-preamble"><h1>Module <code><span>Expect</span></code></h1><p>Expect module for testing interactive program.</p><p>This is a simple implementation of expect to help building unitary testing of interactive program. Since this is an OCaml library, only specific part of expect has been implemented. Other function can be replaced by standard OCaml functions (exit...).</p><p>The use of this library is built around 4 functions:</p><ul><li>spawn: to create a process</li><li>send: to send a string to the process</li><li>expect: match output of the process</li><li>close: end the process</li></ul><p>Output of the program is processed line by line.</p><p>Regular expression is implemented through the library Str. You will need to build a regexp using this module. The regexp should only match a substring of the line. If you need to match something at the beginning or at the end, use &quot;^&quot; and &quot;$&quot;. To use a regexp</p><p>Additional match functions can be build using a standard function. This function is passed the entire line and should return if it match or not.</p><p>There is two additional event to match:</p><ul><li>eof: process close its output</li><li>timeout: too much time has been spent waiting to match something</li></ul><p>Both of this action, if not matched will use the default_action provided.</p><p>Here is an example program, that look for string &quot;.&quot; in the output:</p><pre class="language-ocaml"><code>open Expect

let (), exit_code =
  with_spawn &quot;ls&quot; [|&quot;-alh&quot;|]
  (fun t () -&gt;
    if expect t [`Exact &quot;.&quot;, true] false then
      prerr_endline &quot;'.' found&quot;
    else
      prerr_endline &quot;'.' not found&quot;)
  ()
in
  match exit_code with
  | Unix.WEXITED 0 -&gt;
      print_endline &quot;Exit normal&quot;
  | _ -&gt;
      print_endline &quot;Problem when exiting&quot;</code></pre><p>See <a href="http://directory.fsf.org/project/expect/">Expect manual</a></p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Sylvain Le Gall</li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>A process under the monitoring of Expect.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expect_match"><a href="#type-expect_match" class="anchor"></a><code><span><span class="keyword">type</span> expect_match</span><span> = </span><span>[ </span></code><ol><li id="type-expect_match.Eof" class="def variant constructor anchored"><a href="#type-expect_match.Eof" class="anchor"></a><code><span>| </span><span>`Eof</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Look for EOF</p><span class="comment-delim">*)</span></div></li><li id="type-expect_match.Fun" class="def variant constructor anchored"><a href="#type-expect_match.Fun" class="anchor"></a><code><span>| </span><span>`Fun <span class="keyword">of</span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Look for a line matching the string</p><span class="comment-delim">*)</span></div></li><li id="type-expect_match.Exact" class="def variant constructor anchored"><a href="#type-expect_match.Exact" class="anchor"></a><code><span>| </span><span>`Exact <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Look for a line matching exactly this string</p><span class="comment-delim">*)</span></div></li><li id="type-expect_match.Suffix" class="def variant constructor anchored"><a href="#type-expect_match.Suffix" class="anchor"></a><code><span>| </span><span>`Suffix <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Look for a line ending with this string</p><span class="comment-delim">*)</span></div></li><li id="type-expect_match.Prefix" class="def variant constructor anchored"><a href="#type-expect_match.Prefix" class="anchor"></a><code><span>| </span><span>`Prefix <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Look for a line starting with this string</p><span class="comment-delim">*)</span></div></li><li id="type-expect_match.Contains" class="def variant constructor anchored"><a href="#type-expect_match.Contains" class="anchor"></a><code><span>| </span><span>`Contains <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Look for a line containing this string</p><span class="comment-delim">*)</span></div></li><li id="type-expect_match.Timeout" class="def variant constructor anchored"><a href="#type-expect_match.Timeout" class="anchor"></a><code><span>| </span><span>`Timeout</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Describe expectation about the output of the process. Lines includes the EOL (i.e. \n).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-spawn"><a href="#val-spawn" class="anchor"></a><code><span><span class="keyword">val</span> spawn : 
  <span><span class="optlabel">?verbose</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?verbose_output</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?timeout</span>:<span>float option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?env</span>:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?use_stderr</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>spawn prg args</code> Start a process and monitor its output. Contrary to <code>Unix.create_process</code>, you don't need to repeat the program name at the beginning of args.</p><p>Optional parameters:</p><ul><li><code>~timeout</code>: define the default timeout, in seconds. None means that you can wait forever</li><li><code>~env</code>: provide environment to run the process</li><li><code>~use_stderr</code>: redirect stderr to stdout and process it through expect</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_timeout"><a href="#val-set_timeout" class="anchor"></a><code><span><span class="keyword">val</span> set_timeout : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>float option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Define the timeout for a process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-send"><a href="#val-send" class="anchor"></a><code><span><span class="keyword">val</span> send : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Send a string to a process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expect"><a href="#val-expect" class="anchor"></a><code><span><span class="keyword">val</span> expect : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?fmatches</span>:<span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-expect_match">expect_match</a> * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>expect t ~fmatches matches dflt</code> Waits for output of the process and match it against expectations <code>matches</code>. If no expectations match at timeout, returns <code>dflt</code>. You can use <code>~fmatch</code> to define while processing the output what the result is, if you find a match, return <code>Some res</code> otherwise return <code>None</code>. The function take into account <code>matches</code> before <code>~fmatch</code> and it picks the first result which is not <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Unix</span>.process_status</span></code></div><div class="spec-doc"><p>Close the process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_spawn"><a href="#val-with_spawn" class="anchor"></a><code><span><span class="keyword">val</span> with_spawn : 
  <span><span class="optlabel">?verbose</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?verbose_output</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?timeout</span>:<span>float option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?env</span>:<span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?use_stderr</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>string array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span> * <span class="xref-unresolved">Unix</span>.process_status</span></code></div><div class="spec-doc"><p>Take care of opening and closing the process.</p></div></div></div></body></html>
